<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,200;0,400;0,500;0,600;0,700;1,300;1,400&family=Inter&display=swap" rel="stylesheet">
  <title>julio.lol</title>
  <link id="stylesheet" 
        rel="stylesheet" 
        type="text/css" 
        href="https://jxlxx.github.io/julio.lol/base.css">
</head>
    
<body>
  <script>
  
  const cls = document.body.classList;
  
  (function initTheme() {
    let theme = localStorage.getItem("theme");
    if(theme == "dark") {
      cls.toggle("dark", true);
      cls.toggle("light", false);
    } else {
      cls.toggle("dark", false);
      cls.toggle("light", true);
    }
  })();
  
  
  window.addEventListener("load", (evt) => {
    document.getElementById("dark-mode").addEventListener("click", function(e) {
      localStorage.setItem("theme", "light");
      cls.toggle("dark", false);
      cls.toggle("light", true);
    });
    document.getElementById("light-mode").addEventListener("click", function(e) {
      localStorage.setItem("theme", "dark");
      cls.toggle("light", false)
      cls.toggle("dark", true)
    });
  })
  
  
  </script>
  <div class="header">
    <h1 class="title">
      <span class="hash"> # </span>
      <a href="https://jxlxx.github.io/julio.lol"> julio.lol </a>
      <span id="dark-mode"  class="theme-toggle">üåù</span>
      <span id="light-mode" class="theme-toggle">üåö</span>
    </h1>
    <a class="link" 
       href="https://jxlxx.github.io/julio.lol/about">
    about</a>
    <a class="link" 
       href="https://jxlxx.github.io/julio.lol/projects">
    projects</a>
    <a class="link" 
       href="https://jxlxx.github.io/julio.lol/posts">
    posts</a>
    <a class="link" 
       href="https://jxlxx.github.io/julio.lol/contact">
    contact</a>
  </div>

  <section class="section">
    <div class="container">
      

<div class="go-back">

 <a href="https://jxlxx.github.io/julio.lol"> <span class="left-arrow">‚á¶</span>  go back</a>


</div>

<h1 class="title">
  RADIUS Servers and AAA Basics
</h1>
  A simple explaination of AAA servers, mostly freeRADIUS, and how to get started.
<p class="subtitle"><strong>2022-05-29</strong></p>
<blockquote>
<p><em><strong>free</strong></em>Radius??? Maybe for you... It has cost me everything.</p>
</blockquote>
<h1 id="what-is-radius">What is RADIUS?</h1>
<p>RADIUS is a network protocol.</p>
<p>Servers that accept and send the RADIUS protocol are called radius servers.</p>
<p>Everyone who has used the internet has probably interacted with a radius server. They are commonly used by ISPs, cellular network providers, and corporate/educational networks.</p>
<p>The primary functions of RADIUS is usually referred to as AAA.</p>
<ol>
<li>Authentication
<ul>
<li>are the users/devices who they say they are?</li>
<li>validate some credentials</li>
</ul>
</li>
<li>Authorization
<ul>
<li>are the users/devices allowed to use the network?</li>
</ul>
</li>
<li>Accounting
<ul>
<li>track the usage of the network by users/devices</li>
</ul>
</li>
</ol>
<p>For example, Eduroam uses RADIUS servers.</p>
<p>If you‚Äôre trying to wrap your mind around OpenRoaming, just think about how Eduroam works.</p>
<p>https://eduroam.org/how/</p>
<p>https://wballiance.com/openroaming/how-it-works/</p>
<p>Here is a quick sketch of the physical hardware is involved:</p>
<table><thead><tr><th>Component</th><th>Function</th><th>Hardware</th></tr></thead><tbody>
<tr><td>User/device</td><td>Requests access to the network</td><td>laptop, phone, etc</td></tr>
<tr><td>Network Access Server (NAS)</td><td>Provides access to the network</td><td>Router, Switch, Access Point, VPN Terminator, etc</td></tr>
<tr><td>RADIUS Server</td><td>Receives authentication requests from the NAS. Returns authorization information to NAS. Recieves accounting information.</td><td>freeRADIUS, diameter, Radiator, ISE</td></tr>
</tbody></table>
<p>An important word to note is a NAS. A user/client/device interacts with something refered to as a NAS (Network Access Server) which is something like a router (but could be other things) and that device is what reaches out to the Radius server.</p>
<p>Another important word is <strong>realm</strong>. A realm tells radius what group/organization a user belongs to. Realms are reminisant of email addresses and are used in a somewhat similar way.</p>
<p>The format of a realm is <code>&lt;USER-STRING&gt;@&lt;REALM&gt;</code>.</p>
<h1 id="what-is-freeradius">What is FreeRadius?</h1>
<p>The most commonly used radius server is the freeRadius server. </p>
<p>Setting up a freeRadius server consists of:</p>
<ul>
<li>editing various configuration files</li>
<li>and including/excluding the right files. </li>
</ul>
<p>To run a freeRadius server you must:	</p>
<ul>
<li>put the config files in a file system where freeRadius is expecting them</li>
<li>install the freeRadius software on a local machine, server, or container</li>
<li>run it</li>
</ul>
<p>Here is a simple example directory for a freeRadius configuration:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>raddb/
</span><span>    mods-available/...
</span><span>    mods-enabled/...
</span><span>    sites-available/...
</span><span>    sites-enabled/...
</span><span>    clients.conf
</span><span>    proxy.conf
</span><span>    radiusd.conf
</span></code></pre>
<p>Everything lives inside of a <code>raddb/</code> folder.</p>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><code>mods-available</code></td><td>directory contains sample configurations for all of the modules.</td></tr>
<tr><td><code>mods-enabled</code></td><td>enabled modules; sometimes these are just softlinks to the equivalent file in <code>mods-avaliable</code></td></tr>
<tr><td><code>mods-config</code></td><td>extra configuration for modules</td></tr>
<tr><td><code>sites-available</code></td><td>this contains sample &quot;virtual servers&quot;. Most of these will not be used. They exist as documentation and as examples of &quot;best practices&quot;.</td></tr>
<tr><td><code>sites-enabled</code></td><td>this contains the configuration for &quot;virtual servers&quot; that are being used by the server.</td></tr>
</tbody></table>
<p>The rest of the conf files allow to define how the server listens to requests and what it does with with them.</p>
<p>The <code>radiusd.conf</code> file contains the server configuration.</p>
<p>The <code>proxy.conf</code> file controls the servers behaviour towards ALL other servers to which it sends proxy requests.</p>
<p>The <code>clients.conf</code> file defines RADIUS clients (usually a NAS, Access Point, etc.) by specifying parts and protocols.</p>
<p>In general the syntax of the configuration files looks something like this:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>
</span><span>server name_of_server {
</span><span>	an_authentication_mod
</span><span>
</span><span>	huh {
</span><span>		WHAT
</span><span>	}
</span><span>}
</span><span>
</span></code></pre>
<p>But it depends on what you are configuring exactly.</p>
<h2 id="sections">Sections</h2>
<p>Configuration files are broken up into something called &quot;sections&quot; or sometimes &quot;blocks.&quot;</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>this_is_a_section {
</span><span>
</span><span>}
</span></code></pre>
<p>Some important sections:</p>
<ul>
<li><code>server</code> </li>
<li><code>client</code></li>
<li><code>security</code></li>
<li><code>logging</code></li>
<li>... etc</li>
</ul>
<p>Some important subsections with a <code>server</code> section:</p>
<ul>
<li><code>authorize</code></li>
<li><code>authenticate</code></li>
<li><code>pre-accounting</code></li>
<li><code>accounting</code></li>
<li><code>post-accounting</code></li>
<li><code>proxy</code></li>
<li>... etc</li>
</ul>
<h2 id="helpful-freeradius-documentation">Helpful FreeRadius Documentation</h2>
<ul>
<li><a href="https://networkradius.com/doc/FreeRADIUS%20Technical%20Guide.pdf">Technical Guide</a></li>
<li><a href="https://wiki.freeradius.org/guide/Getting%20Started">Getting Started FreeRadius</a></li>
</ul>
<h1 id="authentication">Authentication</h1>
<p>The radius server receives a request and decides what to do with it. It decides based on:</p>
<ul>
<li>what authentication types you have enabled in the server</li>
<li>what the server can look up in a DB</li>
<li>what‚Äôs in the request</li>
</ul>
<p>The server starts by querying the modules in the authorize section:</p>
<ul>
<li><code>unix</code> module, can you do this?</li>
<li><code>pap</code> module, can you do this?</li>
<li><code>mschap</code> module can you do this?</li>
<li>etc.</li>
</ul>
<p>Until there is some kind of match by one of the modules.
A module will find a match by searching the request for key attributes, such as <code>MS-CHAP-Challenge</code> (for <code>mschap</code>) or <code>EAP-Message</code> (for <code>eap</code>), etc.
If the module does find a match, it sets the <code>Auth-Type</code> to itself.
For example, suppose that the user sent a request with a <code>User-Password</code> attribute and <code>pap</code> is enabled. The pap module will have set <code>Auth-Type=pap</code>.
At the end of the authorize step, the server will check if anything set the <code>Auth-Type</code> if not, it will immediately reject the request.</p>
<p>If anything is missing or in the wrong form?  ‚Üí reject üóë</p>
<p>The naming of the <code>authorize</code> section is kind of misleading. This is really more like a pre-authentication step.</p>
<p>Radius servers can also proxy requests to other servers to do the actual authentication.</p>
<h2 id="network-access-server">Network Access Server</h2>
<p>The NAS acts as the gateway between the user and the wider network.</p>
<p>The NAS will send the users request to access the network to the Radius server. The server will try to authenticate user give the information in the request. After that, the radius server will instruct the NAS whether to allow access to the user and how much.</p>
<p>The NAS acts as the gateway router and firewall for that user.</p>
<p>This means that the server simply returns a decision to the NAS, but it‚Äôs up to the NAS to enforce it.</p>
<p><strong>There is nothing the radius server can do to make the NAS behave as intended.</strong>	</p>
<p>The radius server receives a request and decides what to do with it. Its decision is based on:</p>
<ul>
<li>what authentication types you have enabled in the server</li>
<li>what the server can look up in a DB</li>
<li>what‚Äôs in the request</li>
</ul>
<p>The server cannot request additional information from the NAS, so it has to decided what to do with the information it has. It figures out what to with via policies. A policy can be something like ‚Äúaccept anyone with a correct username/password combo.‚Äù Or more complicated like: ‚Äúallow basic users to request premium services in non-premium hours, except for Sundays and holidays, so long as their payment status is up to date‚Äù</p>
<h2 id="radius-dictionaries">Radius Dictionaries</h2>
<p>Radius is a binary-based protocol, not a text-based one. so when we are talking about attributes in the request, like <code>User-Name</code> they are actually encoded in the message as binary data. Dictionary files are used to map between the names used by people and the binary data in the RADIUS packets.</p>
<p>Packets sent to/from a NAS contain: a number, length, and binary data.</p>
<p>A dictionary file is a list of entries, each of which contain: a name, a number, and a data type.</p>
<p>The server uses the dictionary like this: </p>
<ul>
<li>it searches the dictionaries to match the number in the packet </li>
<li>the corresponding data type is used by the server to interpret the data type </li>
<li>and the name is used in all the debug/logging messages.</li>
</ul>
<p>Note that the NAS and server may use different dictionaries, which may cause problems.</p>
<p>Also note that servers require access to a vendor dictionary to understand vendor attributes.</p>
<h2 id="radiusd-conf"><code>radiusd.conf</code></h2>
<p>The <code>radiusd.conf</code> file contains the server configuration.</p>
<p>The &quot;unlang&quot; policy language can be used to create complex <code>if / else</code> policies. </p>
<p>The client configuration is defined in <code>clients.conf</code>.</p>
<h2 id="configuration-file-syntax">Configuration File Syntax</h2>
<p>Configuration files are UTF-8 text.</p>
<p>They are line-orientated, meaning everything has to be on a separate line.</p>
<p>A configuration item is an internal variable that has a name and holds a value.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>variable = value
</span></code></pre>
<p>Variables have data types. The can be IP addresses, strings, number, etc.</p>
<p>Portions of the configuration can be grouped in sections:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>texas {
</span><span>  dallas = yes
</span><span>  houston = no
</span><span>  san_antonio = 70
</span><span>}
</span></code></pre>
<p>A configuration file can load another configuration file via the <code>$INCLUDE</code> statement:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>$INCLUDE other.conf
</span></code></pre>
<p>Or a directories. Note that dotfiles <code>.imadotfile.conf</code> are ignored but editor ‚Äúbackup‚Äù files with tildes <code>~backup.conf</code> are not. Also this is how you reuse variable definitions:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>somedir = &quot;hello&quot;
</span><span>$INCLUDE ${somedir}/foo/bar/baz
</span></code></pre>
<p>Variable references <code>${var_name}</code> act as macros, and expand when the server loads.</p>
<p>This is different from run-time expansion, which is done like this: <code>%{...}</code></p>
<p>You can also use environment variables:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>$ENV{variable}
</span></code></pre>
<p>And here‚Äôs weird one for fun: </p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>${reference1[name].reference2}
</span></code></pre>
<p>Sections can have instance names:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>section-type instance-name {
</span><span>    [ statements ]
</span><span>}
</span></code></pre>
<p>For example, the <code>client</code> section is used to define information about a client. When multiple clients are defined, they are distinguished by their <code>instance-name</code>.</p>
<h3 id="booleans-are-weird-in-radius">Booleans are weird in radius.</h3>
<p>The boolean data type contains a true or false value. The values <code>yes</code>, <code>on</code>, and <code>1</code> evaluate to <em>true.</em> The values <code>no</code>, <code>off</code>, and <code>0</code> evaluate to <em>false</em>.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>var = yes 
</span></code></pre>
<h3 id="delay-is-a-data-type">Delay is a data type</h3>
<p>Delay is a data type. It contains fractional numbers, like <code>1.4</code>. These numbers are base 10. Usually they are used for timers. The resolution of delay is no more than microseconds, but usually in milliseconds.</p>
<h3 id="words">Words</h3>
<p>A <em>word</em> string is composed of one word, without any surrounding quotes, such as <code>iamaword123</code></p>
<h3 id="strings">Strings</h3>
<p>Strings can have single or double quotes, or back-ticks.</p>
<p>The main difference between the single and double quoted strings is that the double quoted strings can be dynamically expanded.</p>
<p>The syntax <code>${‚Ä¶}</code>  is used for parse-time expansion and <code>%{‚Ä¶}</code> is used for run-time expansion.</p>
<h2 id="some-variables">Some Variables</h2>
<table><thead><tr><th>keyword</th><th>meaning</th></tr></thead><tbody>
<tr><td><code>checkrad</code></td><td>Checkrad is used by the radius server to check if its idea of a user logged in on a certain port/NAS is correct if a double login is detected.</td></tr>
<tr><td><code>cleanup_delay</code></td><td>The time to wait (in seconds) before ‚Äúcleaning up‚Äù a reply that was sent to the NAS.</td></tr>
<tr><td><code>hostname_lookups</code></td><td>Default is no, enabled it mean DNS requests which may take super long and block other requests.</td></tr>
<tr><td><code>libdir</code></td><td>The libdir is where to find the <code>rlm_*</code> modules.</td></tr>
<tr><td><code>max_request_time</code></td><td>Maximum seconds to handle a request.</td></tr>
<tr><td><code>max_requests</code></td><td>The maximum number of requests of which the server keeps track of.</td></tr>
<tr><td><code>panic_action</code></td><td>What to do when panic. Its a string.</td></tr>
<tr><td><code>pidfile</code></td><td>Where to store the PID of the server. To make killing it easier.</td></tr>
</tbody></table>
<h3 id="cleanup-delay"><code>cleanup_delay</code></h3>
<p>The request and replay are usually cached intenally for a short period of time after the reply is sent to the NAS. If the packets gets lost or something, the NAS might send a re-send the request. If too low, then it‚Äôs useless. If it‚Äôs too high, then the server will cache too many requests and some new requests may get blocked (see <code>max_requests</code>).</p>
<h1 id="security-configuration">Security Configuration</h1>
<p>These directives go into a security section, like so:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>security {
</span><span>	...
</span><span>}
</span></code></pre>
<p>I left out a lot but here are some interesting ones:</p>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><code>reject_delay</code></td><td>Seconds to wait before sending an <code>Access-Reject</code>. Slows down DDoS attack and slows down brute force password cracking.</td></tr>
<tr><td><code>status_server</code></td><td>Boolean. Whether to respond to Status-Server requests. See also: <code>raddb/sites-available/status</code></td></tr>
</tbody></table>
<h2 id="thread-pool">Thread pool</h2>
<p>The thread pool is a long-lived group of threads that take turns (round-robin) handling any incoming requests.</p>
<h3 id="max-requests-per-server"><strong><code>max_requests_per_server</code></strong></h3>
<p>Default is 0.</p>
<p>The documentation says: There may be memory leaks or resource allocation problems with the server. If so, set this value to approximately 300 so that the resources will be cleaned up periodically. Not sure what the tradeoff is... do the request after 300 get dropped?</p>
<p>Also: '0' is a special value meaning '<em>infinity</em>' or '<em>the servers never exit</em>'.</p>
<h1 id="virtual-servers">Virtual Servers</h1>
<p>A virtual server is a (nearly complete) RADIUS server.</p>
<p>FreeRADIUS can run multiple virtual servers at the same time. </p>
<p>Virtual servers can even proxy requests to each other.</p>
<p>The simplest way to define a virtual server would be to take all of the request processing sections from <code>radius.conf</code> (<code>authorize</code> , <code>authenticate</code>, etc.) and wrap them in a <code>server {}</code> block.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>server foo {
</span><span>		listen {
</span><span>			ipaddr = 127.0.0.1
</span><span>			port = 2000
</span><span>			type = auth
</span><span>		}
</span><span>
</span><span>		authorize {
</span><span>			update control {
</span><span>				Cleartext-Password := &quot;bob&quot;
</span><span>			}
</span><span>			pap
</span><span>		}
</span><span>
</span><span>		authenticate {
</span><span>			pap
</span><span>		}
</span><span>	}
</span></code></pre>
<p>Only certain sub-sections can appear in a virtual server section:</p>
<ul>
<li><code>listen</code></li>
<li><code>client</code></li>
<li><code>authorize</code></li>
<li><code>authenticate</code></li>
<li><code>port-auth</code></li>
<li><code>pre-proxy</code></li>
<li><code>post-proxy</code></li>
<li><code>preacct</code></li>
<li><code>accounting</code></li>
<li><code>session</code></li>
</ul>
<p>When a <code>listen</code> section is inside of a virtual server definition, it means that all requests sent to that IP/port will be processed through the virtual server. There can not be two <code>listen</code> sections with the same IP address and port number.</p>
<h3 id="authorization-section">Authorization Section</h3>
<p>The name of this section is authorize for historical reasons, as earlier versions of the server did not have a <code>post-auth section</code>. A more accurate description of this section would be <code>pre-authentication</code>.</p>
<p>The authorize section processes <code>Access-Request</code> packets by normalizing the request, determining
which authentication method to use, and either setting the ‚Äúknown good‚Äù password (the valid password found in the database) for the user or informing the server that the request should be proxied.</p>
<p>Once the authorize section has finished processing the packet, the return code for the section is examined by the server. If the return code is <code>noop</code>, <code>notfound</code>, <code>ok</code>, or <code>updated</code>, then request processing continues.</p>
<p>If the return code is <code>handled</code>, then it is presumed that one of the modules set the contents of the reply, and the server sends the reply message. </p>
<p>Otherwise, the server treats the authentication as being rejected and runs the <code>post-auth</code> section.</p>
<p>If the authentication has not been rejected, then the server continues processing the request by
searching for the <code>Auth-Type</code> attribute. Then the named sub-section of <code>authenticate</code> is executed. </p>
<p>The authorization section is starts when the server receives an <code>Access-Request</code> packet.</p>
<p>First preprocesses (<code>hints</code> and <code>huntgroups</code>), then does <code>realms</code>, then finally the <code>users</code> file.</p>
<p>The order of the realm modules will determine the order in which a matching realm is found. </p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>authorize {
</span><span>  filter-username
</span><span>  preprocess
</span><span>  # operator-name
</span><span>  # cui
</span><span>  # authlog
</span><span>  chap
</span><span>  mschap
</span><span>	digest
</span><span>	# mimax
</span><span>	# IPASS
</span><span>	suffix 
</span><span>  ntdomain
</span><span>  eap {
</span><span>		ok = return
</span><span>  }
</span><span>  # unix
</span><span>  files
</span><span>  -sql
</span><span>  # smbpasswd
</span><span>  -ldap
</span><span>  # daily
</span><span>	expiration
</span><span>	logintime
</span><span>	pap
</span><span>	Autz-Type Status-Server {
</span><span>  
</span><span>	}
</span><span>}
</span></code></pre>
<p><code>filter-username</code> this is a policy that sanitizing usernames in requests by removing garbage like spaces and invalid characters. If it appears invalid, the request is rejected. </p>
<p>See <code>policy.d/filter</code> for the definition of the <code>filter-username</code> policy.</p>
<p><code>preprocess</code> sanitizes the non-standard format attributes in the request and makes them standard.</p>
<p>(I think that this mean like how a mac address can be written in like 6953 different ways)</p>
<p>If <code>CUI</code> is used then <code>Operator-Name</code> is required to be set for CUI generation.</p>
<p>Not sure what this means or why it is true.</p>
<p><code>auth_log</code> generates a log of authentication requests.</p>
<p><code>chap</code> sets <code>Auth-Type := CHAP</code> for requests which contain a <code>CHAP-Password</code> attribute.</p>
<p>When users log in with an <code>MS-CHAP-Challenge</code> attribute for authentication, the <code>mschap</code> module finds the <code>MS-CHAP-Challenge attribute</code> and adds <code>Auth-Type := MS-CHAP</code> to the request, which causes the server to then use the <code>mschap</code> module for authentication.</p>
<p><code>digest</code>is for SIP (session initiation protocol) servers. (VoIP). who cares.</p>
<p>WiMAX refers to implementations of the <a href="https://en.wikipedia.org/wiki/IEEE_802.16">IEEE 802.16</a> family of wireless-networks standards created by the WiMAX Forum. The WiMAX specification states that the <code>Calling-Station-Id</code> is 6 octets of the MAC.</p>
<p>This definition conflicts with with all common RADIUS practices. Uncommenting the <code>wimax</code> module here means that it will fix the <code>Calling-Station-Id</code> attribute to the normal format. whatever.</p>
<p>üí° <em><strong>Did you know</strong></em>: WiMAX was sometimes referred to as &quot;Wi-Fi on steroids&quot;<a href="https://en.wikipedia.org/wiki/WiMAX#cite_note-5">[5]</a> lol</p>
<p>Looks for <code>IPASS</code>-style <code>realm/</code> and, if not found, looks for <code>@realm</code> and decides whether or not to proxy based on those results.</p>
<p>When using multiple kinds of realms, set <code>ignore_null = yes</code> for all of them. Otherwise, if the first style of realm doesn‚Äôt match, then the other styles won‚Äôt be checked.</p>
<p>The <code>eap</code> module takes care of <code>EAP-MD5</code>, <code>EAP-TLS</code>, and <code>EAP-LEAP</code> authentication.</p>
<p><code>unix</code> pulls crypt‚Äôd passwords from <code>/etc/passwd</code> or <code>/etc/shadow</code> using the system APIs to get the password.</p>
<p><code>files</code> reads the <code>radbb/users</code> file.</p>
<p>The <code>-sql</code>  module looks in an SQL database. I don‚Äôt know why it gets a dash, but <code>-ldap</code> gets one too, so maybe its a theme.</p>
<p>... skipping a couple idc</p>
<p><code>daily</code> enforces daily limits on time spent logged in. I think it requires <code>expiration</code> and <code>logintime</code></p>
<p>If no other module has claimed responsibility for authentication, then try <code>pap</code>. This process allows the other modules listed above to only add a &quot;known good&quot; password to the request and nothing else. The PAP module will then see that password and use it to do PAP authentication. This module should be listed last so that the other modules get a chance to set <code>Auth-Type</code> for themselves.</p>
<p>If <code>status_server = yes</code>, then <code>Status-Server</code> messages are passed through the following section and <strong>only</strong> the following section.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>Autz-Type Status-Server {
</span><span>
</span><span>}
</span></code></pre>
<h3 id="authentication-section">Authentication Section</h3>
<p>This section lists those modules that are available for authentication. </p>
<p>Note that the order of modules listed below does <strong>not</strong> mean ‚Äútry each module in order‚Äù. </p>
<p>Instead, a module from the <code>authorize</code> section adds a configuration attribute <code>Auth-Type := FOO</code>. That authentication type is then used to pick the appropriate module from the list below.</p>
<p>The authenticate section is only used when the server is authenticating requests locally and is
bypassed completely when proxying.</p>
<p>This section is different from each of the other sections: it is composed of a series of subsections, only one of which is executed.</p>
<p>The <code>Auth-Type</code> attribute can also refer to a module (e.g. <code>eap</code>) instead of a subsection, in which case that module, and only that module, is processed.</p>
<p>A simple example:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>authenticate {
</span><span>	Auth-Type PAP {
</span><span>		pap
</span><span>	}
</span><span>	Auth-Type MS-CHAP {
</span><span>		mschap
</span><span>	}
</span><span>	Auth-Type CHAP {
</span><span>		chap
</span><span>	}
</span><span>	eap
</span><span>}
</span></code></pre>
<p>In general, the <code>Auth-Type</code> attribute <strong>should not</strong> be set. The server will figure it out on its own and will do the right thing. The above is just defining <code>Auth-Types</code> but not actually setting the attribute.</p>
<p>Do not put <code>unlang</code> configurations into the <code>authenticate</code> section. Put them in the <code>post-auth</code> section instead. That‚Äôs what the <code>post-auth</code> section is for.</p>
<h3 id="pre-accounting-section">Pre-accounting Section</h3>
<p>This section decides which accounting type to use.</p>
<p>Session start times are <strong>implied</strong> in RADIUS. The NAS never sends a &quot;start time&quot;. Instead, it sends a start packet, <strong>possibly</strong> with an Acct-Delay-Time.</p>
<p>You can create a start time with the following code:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>update request {
</span><span>	FreeRADIUS-Acct-Session-Start-Time = &quot;%{expr: %l - %\{%{Acct-Session-Time}:-0} - %\{%{Acct-Delay-Time}:-0}}&quot;
</span><span>}
</span></code></pre>
<p><code>acct_unique</code> ensures that a semi-unique identifier is available for every request because many NAS boxes are broken.</p>
<p>The <code>files</code>  module reads the <code>acct_user</code> file.</p>
<h3 id="accounting-section">Accounting Section</h3>
<p>The <code>accounting</code> section Iogs the accounting data.</p>
<p><code>cui</code> updates accounting packets by adding the <code>CUI</code> attribute from the corresponding <code>Access-Accept</code>. It's used for when the NAS doesn‚Äôt support CUI themselves.</p>
<p><code>detail</code> creates a <code>detail</code>'ed log of the packets.</p>
<p><code>-sql</code> logs traffic into a SQL db.</p>
<p><code>exec</code> is for <code>Exec-Program</code> and <code>Exec-Program-Wait</code>.</p>
<h3 id="post-authentication-section">Post-authentication Section</h3>
<p>Once it is <strong>verified</strong> that the user has been authenticated, there are additional steps that can be taken.</p>
<h3 id="pre-proxy-section">Pre-proxy Section</h3>
<p>TODO</p>
<h3 id="post-proxy-section">Post-proxy Section</h3>
<p>TODO</p>
<h1 id="what-is-an-inner-tunnel">What is an inner-tunnel</h1>
<p>TODO</p>
<h1 id="what-is-an-idp">What is an IdP</h1>
<p>TODO</p>


</div>


    </div>
  </section>
</body>
</html>

